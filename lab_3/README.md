# Лабораторная работа №3. Функции.

До сих пор мы писали весь код в одном месте в блоке `main`. Так как программы были небольшими, проблем никаких не возникало. Но с усложнением задач код может разрастись до сотен и тысяч строк, тогда такой код будет очень сложно восприниматься. В этом случае зачастую код программы разбивается на подпрограммы, или функции.

## Главная, или `main`, функция

Мы уже встречались с одной функцией, которая называется `main`. Эта функция является точкой входа в нашу программу. Т.е. при запуске программы в первую очередь запустится именно функция `main`.

```cpp
#include <iostream>

int main() 
{
    cout << "Hello, world!" << "\n";
    return 0;
}
```

## Определение функции

Для удобства давайте введем формальное определение функции:
```cpp
тип_данных имя_функции(тип_данных1 параметр1, ..., тип_данныхN параметрN)
{
    тело функции;
    возвращаемое значение;
}
```

Итак, определение функции начинается с типа данных, возвращаемых функцией. Функция возвращает данные ключевым словом `return`. Тип данных возвращаемого значения должен соответствовать типу данных в определении функции. Например, в примере выше функция `main` возвращает тип данных `int`, поэтому после `return` так же должна стоять переменная с типом данных `int`.

После возвращаемого типа данных через пробел идет имя функции. Его программист выбирает сам. Правила для именования функций совпадают с правилами именования переменных: начинается с большой или маленькой английской буквы или с символа подчеркивания, следующий символ может быть подчеркиванием, цифрой или английской буквой. Например, допустимые имена:

```cpp
int number;
float number2;
double _aaa;
std::string fullName;
std::string full_name;
```

После имени функции в скобках перечисляются параметры, принимаемые функцией. Функция может не принимать никаких параметров, как в случае с вышеупомянутой функцией `main`, но может получать любое количество параметров. Если параметров больше, чем один, они отделяются запятой. Полученные функцией параметры могут использоваться внутри тела функции. 

Давайте напишем функцию, которая будет приветствовать пользователя по тому имени, которое он введет в консоль:

```cpp
void greetings(std::string name)
{
    std::cout << "Greetings, " << name << ". Nice to meet you!" << "\n";
}
```

Здесь мы встретили новый тип данных `void`. В переводе с английского означает `пустой`. Это означает, что функция не возвращает никакого значения. В самом деле, в нашем случае наша функция просто выводит приветствие на консоль, ей незачем возвращать какое-либо значение. 

Теперь мы должны вставить эту функцию внутрь функции `main`, чтобы ее *вызвать*. Обратите внимание, функция `greetings` определена выше функции `main`, если мы поместим ее ниже, то функция `main` не сможет "увидеть" функцию `greetings`, и компилятор выдаст ошибку компиляции. 

```cpp
#include <iostream>
#include <string>

void greetings(std::string name)
{
    std::cout << "Greetings, " << name << ". Nice to meet you!" << "\n";
}

int main()
{
    std::string name1, name2;

    std::cout << "Input first name:\n";
    std::cin >> name1;
    greetings(name1);

    std::cout << "Input second name:\n";
    std::cin >> name2;
    greetings(name2);

    return 0;
}
```

Вывод:

```console
Input first name:
Danil
Greetings, Danil. Nice to meet you!
Input second name:
Artyom
Greetings, Artyom. Nice to meet you!
```

В данном примере мы определили функцию `greetings`, которая принимает один параметр `name` с типом данных `std::string`. Для того, чтобы **передать** в нее переменную, необходимо поместить ее внутри скобок. Запись `greetings(name1)` означает, что мы **вызываем** функцию `greetings` и **передаем** в нее переменную `name1`. Переменная `name1` "встанет" на место параметра `std::string name` в объявлении функции и как бы заменит ее.

Параметры, которые задаются в определении функции, называются *формальными параметрами*, а параметры, которые передаются при вызове функции, называются *фактическими параметрами*. При вызове функции фактические параметры заменяют формальные.

## Функции с возвращаемым значением

Функция `greetings` не возвращала никаких данных, но зачастую нам необходимо проделать какие-либо манипуляции с данными, передаваемыми в функцию, и вернуть полученный результат. Давайте рассмотрим пример простой функции, вычисляющей сумму чисел от `a` до `b` включительно. Назовем ее `rangeSum`:

```cpp
int rangeSum(int a, int b)
{
    int result;
    for (int i = a; i <= b; i++)
    {
        result += i;
    }
    return result;
}

int main()
{
    int a, b;
    std::cin >> a >> b;
    int res = rangeSum(a, b);
    std::cout << "Range sum from " << a << " to " << b 
              << " is equal to " << res << "\n";
    return 0;
}
```

В данной функции мы принимаем 2 параметра c типом данных `int` и возвращаем так же тип данных `int`. Внутри функции `rangeSum` мы создали дополнительную переменную, которую будем возвращать в конце работы функции. Так как эта функция возвращает значение с типом данных `int`, то мы можем присвоить это значение переменной с типом данных `int`, в данном случае переменной `res`.

## Область видимости

Область видимости представляет часть программы, в пределах которой можно использовать объект. Как правило, область видимости ограничивается блоком кода, который заключается в фигурные скобки. В зависимости от области видимости создаваемые объекты могут быть *глобальными* или *локальными*.

Каждая функция задает свою область видимости для переменных. Мы не сможем обратиться к переменной `result` из функции `rangeSum` внутри функции `main`, поскольку последняя не видит переменные внутри функции `rangeSum`. Таким же образом мы не сможем обратиться к переменным `a` и `b` из функции `main` внутри функции `rangeSum`. Эти переменные являются локальными переменными и видны только внутри тела функции. 

Глобальные же функции определяются вне функций и доступны в любом месте, в любом кусочке кода. Например:

```cpp
#include <iostream>

int a = 10;

void test(int a)
{
    a += 10;
    std::cout << a << "\n"; // 20
}

int main() 
{
    std::cout << a << "\n"; // 10
    test(a); // 20
    std::cout << a << "\n"; // 10
    return 0;
}
```

Несмотря на то, что внутри функции `test` мы увеличили значение переменной `a` на 10, сама переменная `а` не изменилась, поскольку внутри функции `test` создалась локальная копия этой переменной. Поговорим об этом подробнее. 

## Передача параметров по значению и по ссылке