# Лабораторная работа №3. Функции.

До сих пор мы писали весь код в одном месте в блоке `main`. Так как программы были небольшими, проблем никаких не возникало. Но с усложнением задач код может разрастись до сотен и тысяч строк, тогда такой код будет очень сложно восприниматься. В этом случае зачастую код программы разбивается на подпрограммы, или функции.

## Главная, или `main`, подпрограмма

Мы уже встречались с одной подпрограммой, которая называется `main`. Эта подпрограмма является точкой входа в нашу программу. Т.е. при запуске программы в первую очередь запустится именно подпрограмма `main`.

```cpp
#include <iostream>

int main() 
{
    cout << "Hello, world!" << "\n";
    return 0;
}
```

## Определение подпрограммы

Для удобства давайте введем формальное определение подпрограммы:
```cpp
тип_данных имя_функции(тип_данных1 параметр1, ..., тип_данныхN параметрN)
{
    тело функции;
    возвращаемое значение;
}
```

Итак, определение подпрограммы начинается с типа данных, возвращаемых подпрограммой. Если подпрограмма возвращает данные ключевым словом `return`, то такая подпрограмма называется **функцией**. Тип данных возвращаемого значения должен соответствовать типу данных в определении функции. Например, в примере выше функция `main` возвращает тип данных `int`, поэтому после `return` так же должна стоять переменная с типом данных `int`.

После возвращаемого типа данных через пробел идет имя подпрограммы. Его программист выбирает сам. Правила для именования подпрограмм совпадают с правилами именования переменных: начинается с большой или маленькой английской буквы или с символа подчеркивания, следующий символ может быть подчеркиванием, цифрой или английской буквой. Например, допустимые имена:

```cpp
int number() {...};
float number2() {...};
double _aaa() {...};
std::string fullName() {...};
std::string full_name() {...};
```

После имени подпрограммы в скобках перечисляются параметры, принимаемые функцией. подпрограмма может не принимать никаких параметров, как в случае с вышеупомянутой функцией `main`, но также может получать любое количество параметров. Если параметров больше, чем один, они отделяются запятой. Полученные подпрограммой параметры могут использоваться внутри тела подпрограммы. 

Давайте напишем подпрограмму, которая будет приветствовать пользователя по тому имени, которое он введет в консоль:

```cpp
void greetings(std::string name)
{
    std::cout << "Greetings, " << name << ". Nice to meet you!" << "\n";
}
```

Здесь мы встретили новый тип данных `void`. В переводе с английского означает `пустой`. Это означает, что подпрограммы не возвращает никакого значения. В самом деле, в нашем случае наша подпрограммы просто выводит приветствие на консоль, ей незачем возвращать какое-либо значение. Такая подпрограмма, которая не возвращает значений, называется **процедурой**.

Теперь мы должны вставить эту процедуру внутрь функции `main`, чтобы ее *вызвать*. Обратите внимание, процедура `greetings` определена выше функции `main`, если мы поместим ее ниже, то функция `main` не сможет "увидеть" процедуру `greetings`, и компилятор выдаст ошибку компиляции. 

```cpp
#include <iostream>
#include <string>

void greetings(std::string name)
{
    std::cout << "Greetings, " << name << ". Nice to meet you!" << "\n";
}

int main()
{
    std::string name1, name2;

    std::cout << "Input first name:\n";
    std::cin >> name1;
    greetings(name1);

    std::cout << "Input second name:\n";
    std::cin >> name2;
    greetings(name2);

    return 0;
}
```

Вывод:

```console
Input first name:
Danil
Greetings, Danil. Nice to meet you!
Input second name:
Artyom
Greetings, Artyom. Nice to meet you!
```

В данном примере мы определили процедуру `greetings`, которая принимает один параметр `name` с типом данных `std::string`. Для того, чтобы **передать** в нее переменную, необходимо поместить ее внутри скобок. Запись `greetings(name1)` означает, что мы **вызываем** процедуру `greetings` и **передаем** в нее переменную `name1`. Переменная `name1` "встанет" на место параметра `std::string name` в объявлении процедуры и как бы заменит ее.

Параметры, которые задаются в определении подпрограммы, называются *формальными параметрами*, а параметры, которые передаются при вызове подпрограммы, называются *фактическими параметрами*. При вызове подпрограммы фактические параметры заменяют формальные.

## Функции с возвращаемым значением

Далее я буду называть и процедуры, и функции одним словом - **функция**. Помните, если подпрограмма не возвращает значения, то она называется *процедурой*, а если возвращает - то *функцией*.

Функция `greetings` не возвращала никаких данных, но зачастую нам необходимо проделать какие-либо манипуляции с данными, передаваемыми в функцию, и вернуть полученный результат. Давайте рассмотрим пример простой функции, вычисляющей сумму чисел от `a` до `b` включительно. Назовем ее `rangeSum`:

```cpp
int rangeSum(int a, int b)
{
    int result = 0;
    for (int i = a; i <= b; i++)
    {
        result += i;
    }
    return result;
}

int main()
{
    int a, b;
    std::cin >> a >> b;
    int res = rangeSum(a, b);
    std::cout << "Range sum from " << a << " to " << b 
              << " is equal to " << res << "\n";
    return 0;
}
```

В данной функции мы принимаем 2 параметра c типом данных `int` и возвращаем так же тип данных `int`. Внутри функции `rangeSum` мы создали дополнительную переменную, которую будем возвращать в конце работы функции. Так как эта функция возвращает значение с типом данных `int`, то мы можем присвоить это значение переменной с типом данных `int`, в данном случае переменной `res`.

## Область видимости

Область видимости представляет часть программы, в пределах которой можно использовать объект. Как правило, область видимости ограничивается блоком кода, который заключается в фигурные скобки. В зависимости от области видимости создаваемые объекты могут быть *глобальными* или *локальными*.

Каждая функция задает свою область видимости для переменных. Мы не сможем обратиться к переменной `result` из функции `rangeSum` внутри функции `main`, поскольку последняя не видит переменные внутри функции `rangeSum`. Таким же образом мы не сможем обратиться к переменным `a` и `b` из функции `main` внутри функции `rangeSum`. Эти переменные являются локальными переменными и видны только внутри тела функции. 

Глобальные же функции определяются вне функций и доступны в любом месте, в любом кусочке кода. Например:

```cpp
#include <iostream>

int a = 10;

void test(int a)
{
    a += 10;
    std::cout << a << "\n"; // 20
}

int main() 
{
    std::cout << a << "\n"; // 10
    test(a); 
    std::cout << a << "\n"; // 10
    return 0;
}
```

Несмотря на то, что внутри функции `test` мы увеличили значение переменной `a` на 10, сама переменная `а` не изменилась, поскольку внутри функции `test` создалась локальная копия этой переменной. Поговорим об этом подробнее. 

## Передача параметров по значению и по ссылке

Из примера выше мы увидели, что при передаче данных в функцию, в ней создавалась локальная копия переменной. Это называется *передачей параметра по значению*. В этом случае мы не можем изменить исходную переменную.

Если же нам необходимо изменить исходную переменную, то мы должны *передать параметр по ссылке*. Рассмотрим, как это делается:

```cpp
#include <iostream>

int a = 10;

void test(int &a)
{
    a += 10;
    std::cout << a << "\n"; // 20
}

int main() 
{
    std::cout << a << "\n"; // 10
    test(a); 
    std::cout << a << "\n"; // 20
    return 0;
}
```

Теперь значение переменной `а` изменилось не только внутри функции `test`, но и в функции `main`. На самом деле мы всего лишь добавили один знак в обьявлении функции `test`. Теперь параметр `int &a` включает в себя знак &(амперсанд). Именно он отвечает за то, что параметр будет передаваться по ссылке. Т.е. внутри функции не будет создаваться локальная копия переменной, а будет использоваться *ссылка* на эту переменную. Подробнее про ссылки и указатели будет рассказано в дальнейшем.

## Перегрузка функций

Перегрузка функции - это функция с таким же именем, но другим объявлением. Проще всего показать это на примере. Например, мы хотим, чтобы функция `rangeSum` могла вычислять сумму чисел от `a` до `b` не только в целых числах, но и в вещественных, причем с заданным шагом.
```cpp
int rangeSum(int a, int b)
{
    int result = 0;
    for (int i = a; i <= b; i++)
    {
        result += i;
    }
    return result;
}

double rangeSum(int a, int b, double step)
{
    double result = 0.0;
    for (double i = a; i <= b; i += step)
    {
        result += i;
    }
    return result;
}
```

Для такой задачи мы можем написать две функции с одинаковым именем, но разными объявлениями и реализациями. В данном случае мы перегрузили функцию `int rangeSum(int a, int b)` функцией `rangeSum(int a, int b, double step)`. Теперь в зависимости от количества принимаемых аргументов будет вызвана нужная функция:

```cpp
int main()
{
    int a = 1; 
    int b = 5;

    int res = rangeSum(a, b);
    std::cout << "Result: " << res << "\n"; // 15

    double res2 = rangeSum(a, b, 0.32);
    std::cout << "Result: " << res2 << "\n"; // 37.96

    return 0;
}
```
